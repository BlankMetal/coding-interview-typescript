/**
 * ============================================
 * TEST RUNNER - DO NOT EDIT THIS FILE
 * ============================================
 * 
 * This file orchestrates the test execution.
 * All configuration is done in lib/solution.ts
 */

import { calc, BACKEND_ENDPOINT } from "./solution";

// Test cases are dynamic arrays of parameters
type TestCase = (number | string | null)[];

interface TestResult {
  testCase: number;
  inputs: TestCase;
  result: number;
  passed?: boolean;
}

export async function runTests(
  challengeLevel?: number,
  scenarioName?: string
): Promise<{
  results: TestResult[];
  summary?: {
    total: number;
    passed: number;
    failed: number;
    levelPassed?: number;
  };
  error?: string;
}> {
  try {
    // Check if backend endpoint is configured
    if (!BACKEND_ENDPOINT || BACKEND_ENDPOINT.trim() === "") {
      return {
        results: [],
        error: "BACKEND_ENDPOINT not configured. Please paste the endpoint URL provided during your interview into lib/solution.ts",
      };
    }

    // Fetch test cases from backend
    const testCasesUrl = new URL(`${BACKEND_ENDPOINT}/test-cases`);
    if (challengeLevel) {
      testCasesUrl.searchParams.append('challenge_level', challengeLevel.toString());
    }
    if (scenarioName) {
      testCasesUrl.searchParams.append('scenario_name', scenarioName);
    }

    const testCasesResponse = await fetch(testCasesUrl.toString());

    if (!testCasesResponse.ok) {
      throw new Error(
        `Failed to fetch test cases: ${testCasesResponse.statusText}\n\n` +
        `ðŸ’¡ Hint: If the interview hasn't started yet, please wait until you receive a backend URL from your interviewer and add it to BACKEND_ENDPOINT in lib/solution.ts`
      );
    }

    const testCases: TestCase[] = await testCasesResponse.json();

    // Run the calc function for each test case
    const results = testCases.map((testCase) => {
      // Spread the test case parameters directly into calc
      return calc(...testCase);
    });

    // Submit results to backend for validation
    const checkResponse = await fetch(`${BACKEND_ENDPOINT}/check-results`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        results,
        challenge_level: challengeLevel,
        scenario_name: scenarioName
      }),
    });

    if (!checkResponse.ok) {
      throw new Error(
        `Failed to check results: ${checkResponse.statusText}\n\n` +
        `ðŸ’¡ Hint: If the interview hasn't started yet, please wait until you receive a backend URL from your interviewer and add it to BACKEND_ENDPOINT in lib/solution.ts`
      );
    }

    const validationData = await checkResponse.json();

    // Combine test cases with validation results
    const finalResults: TestResult[] = testCases.map((testCase, index) => {
      const validation = validationData.results[index];
      return {
        testCase: index + 1,
        inputs: testCase,
        result: results[index],
        passed: validation.passed,
      };
    });

    return {
      results: finalResults,
      summary: validationData.summary,
    };
  } catch (error) {
    console.error("Error running tests:", error);
    let errorMessage = error instanceof Error ? error.message : "An unknown error occurred";

    // Add hint for connection/network errors
    if (error instanceof TypeError && error.message.includes('fetch')) {
      errorMessage += "\n\nðŸ’¡ Hint: If the interview hasn't started yet, please wait until you receive a backend URL from your interviewer and add it to BACKEND_ENDPOINT in lib/solution.ts";
    }

    return {
      results: [],
      error: errorMessage,
    };
  }
}
